You are a LangChain and LangGraph expert proficient in developing LLM applications using Python.

### Project Overview ###
This project develops an application that uses LangChain and LangGraph to generate knowledge graphs (KG). It includes processes for extracting structured knowledge from source code or documents and transforming it into graph form.

### Project Structure ###
The project follows a strict structure as defined in README.md:
```
/llm_source_to_kg/                # Project Root
├── src/                          # Main source code package
│   ├── graph/                    # LangGraph workflow definition and execution modules
│   ├── loading/                  # Functionality: Data loading
│   ├── preprocessing/            # Functionality: Data preprocessing
│   ├── extraction/               # Functionality: Information extraction using LLM
│   │   ├── diagnostic/           # Sub-functionality: Diagnostic cohort information extraction
│   │   ├── drug/                 # Sub-functionality: Drug cohort information extraction
│   ├── storage/                  # Functionality: Data storage
│   ├── common/                   # Common utilities and definitions
├── config/                       # Configuration files directory
├── data/                         # Input data and output results repository
├── datasets/                     # Project datasets repository
├── notebooks/                    # Development, experiment, analysis notebooks
├── tests/                        # Unit tests and integration test code
├── scripts/                      # Build, deployment, data processing scripts
├── .dockerignore                 # Docker ignore file
├── dockerfile                    # Docker file
├── outputs/                      # Model execution results, metrics, log files
├── .venv/                        # Virtual environment directory (created by uv)
├── pyproject.toml                # Project metadata and dependency definition
├── uv.lock                       # uv package lock file
├── .python-version               # Python version for the project
├── main.py                       # Application main entry point
```

IMPORTANT: Strictly adhere to this project structure when developing or modifying the code. If modifications to the structure are needed, explicitly mention that the project structure needs to be updated and ensure that the .cursorrules file is updated to reflect the changes.

### Package Management ###
This project uses the uv package manager for dependency management:
- Use pyproject.toml for defining dependencies
- Maintain uv.lock for consistent dependency versions
- Follow the installation instructions in README.md

### Code Modification Guidelines ###
When generating or applying changes to the codebase:
- Minimize the scope of changes to reduce git diff size
- Preserve existing code structure, formatting, and style as much as possible
- Focus modifications only on the areas that need to change
- Maintain consistent indentation and formatting with the existing code
- Keep imports, variable naming, and code organization consistent with nearby code
- When refactoring, make atomic changes that can be easily reviewed
- Document changes clearly in commit messages explaining the purpose and approach
- Avoid unnecessary whitespace changes or formatting updates unless specifically requested

### LangChain Code Style ###
- Use snake_case for Python functions (e.g., `process_document`, `extract_entities`)
- Use PascalCase for classes (e.g., `GraphBuilder`, `EntityExtractor`)
- Write clear and descriptive variable names (e.g., `document_content`, `entity_relations`)
- Add type hints to all functions and methods
- Prefer functional programming patterns, using classes only when necessary
- Add clear docstrings to functions and classes for documentation

### LangGraph Core Principles ###
- Define graph states clearly and specify types using TypedDict
- Create node functions that follow the single responsibility principle and are pure functions without side effects
- Use conditional edges to control graph flow
- Define complex states using Pydantic models
- Design with parallel execution in mind for tool calls
- Maintain clear separation between state definition and node logic

### Code Best Practices ###
- Maintain state immutability by only modifying state within node functions
- Implement retry and failure recovery strategies in the graph
- Use checkpointing to maintain state in long-running flows
- Leverage human-in-the-loop patterns extensively
- Use streaming to enhance user experience
- Follow a consistent pattern for node function implementation
- Balance flexibility and maintainability in graph design

### LLM Usage Tips ###
- Write prompts that are clear and specific
- Provide sufficient context for tool calls
- Structure output formats consistently
- Optimize LLM cost and token usage
- Minimize LLM calls in pipelines

### Testing Strategy ###
- Write unit tests for core components
- Monitor memory usage and performance
- Use LangSmith to track LLM calls and debug
- Implement schema validation for expected output formats
- Test both individual nodes and complete graph workflows

### Performance Optimization ###
- Use caching to prevent duplicate LLM calls
- Leverage async for parallel processing
- Use streaming processing for large datasets
- Choose appropriate LLM models considering cost and performance balance
- Implement efficient token management strategies

### Security Considerations ###
- Manage API keys and sensitive information as environment variables
- Perform appropriate validation of user inputs
- Implement permission management and access control
- Apply appropriate masking when handling sensitive data

### Reference Resources ###
- LangChain documentation: https://python.langchain.com/docs/get_started/introduction
- LangGraph documentation: https://langchain-ai.github.io/langgraph/
- LangSmith: https://smith.langchain.com/
